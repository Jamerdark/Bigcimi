name: ğŸ—ï¸ Build MinUI with CI Patches

on:
  workflow_dispatch:
    inputs:
      target_device:
        description: 'Target device/platform'
        required: true
        default: 'rg35xx'
        type: choice
        options:
        - rg35xx
        - rgb30
        - miyoomini
        - default
      clean_build:
        description: 'Clean build directory'
        required: true
        default: true
        type: boolean
      create_release:
        description: 'Create GitHub Release'
        required: true
        default: false
        type: boolean
      release_tag:
        description: 'Release tag name'
        required: false
        default: ''

  # Auto build on push to main
  push:
    branches: [main, master]
    paths:
      - '.github/workflows/**'
      - 'scripts/**'
      - 'patches/**'

  # Schedule daily build
  schedule:
    - cron: '0 2 * * *'  # 2 AM UTC daily

env:
  MINUI_REPO: "https://github.com/shauninman/MinUI.git"
  BUILD_DIR: "minui-build"
  OUTPUT_DIR: "artifacts"

jobs:
  setup-and-patch:
    name: "âš™ï¸ Setup & Patch"
    runs-on: ubuntu-latest
    outputs:
      build_version: ${{ steps.version.outputs.version }}
      commit_hash: ${{ steps.clone.outputs.commit_hash }}
      cache_key: ${{ steps.cache-key.outputs.key }}
    
    steps:
    - name: "ğŸ“¦ Checkout builder repository"
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        
    - name: "ğŸ”„ Clone MinUI repository"
      id: clone
      run: |
        echo "Cloning MinUI from $MINUI_REPO"
        rm -rf $BUILD_DIR
        git clone --depth 1 $MINUI_REPO $BUILD_DIR
        
        # Get commit hash
        cd $BUILD_DIR
        COMMIT_HASH=$(git rev-parse --short HEAD)
        echo "commit_hash=$COMMIT_HASH" >> $GITHUB_OUTPUT
        echo "ğŸ“Œ MinUI commit: $COMMIT_HASH"
        
    - name: "ğŸ”§ Apply CI patches"
      run: |
        echo "Applying patches to MinUI..."
        cd $BUILD_DIR
        
        # Create Makefile backup before patching
        cp makefile makefile.orig
        
        # Check if patches directory exists
        if [ -d "../patches" ]; then
          echo "ğŸ“‹ Found patches directory"
          
          # Apply patch file if exists
          if [ -f "../patches/minui-ci.patch" ]; then
            echo "ğŸ“‹ Applying patch file..."
            # Disable tty for patch command to avoid issues
            patch --no-tty -p1 -i "../patches/minui-ci.patch" || echo "â„¹ï¸ Patch may have been already applied or partially applied"
          fi
          
          # Run patch script if exists
          if [ -f "../patches/apply-patch.sh" ]; then
            echo "ğŸ“‹ Running patch script..."
            chmod +x "../patches/apply-patch.sh"
            "../patches/apply-patch.sh" || echo "â„¹ï¸ Patch script completed"
          fi
        else
          echo "âš ï¸ No patches directory found"
        fi
        
        # Verify patches by comparing with original
        echo "âœ… Patch verification:"
        echo "Differences in Makefile:"
        diff -u makefile.orig makefile | head -20 || true
        
    - name: "ğŸ“ Generate build version and cache key"
      id: version
      run: |
        cd $BUILD_DIR
        DATE=$(date +%Y%m%d)
        COMMIT_SHORT=$(git rev-parse --short HEAD)
        VERSION="MinUI-$DATE-$COMMIT_SHORT"
        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "ğŸ·ï¸ Build version: $VERSION"
        
        # Generate cache key
        CACHE_KEY="${{ runner.os }}-minui-$COMMIT_SHORT-$(date +%s)"
        echo "cache_key=$CACHE_KEY" >> $GITHUB_OUTPUT
        
    - name: "ğŸ’¾ Cache patched source"
      uses: actions/cache@v3
      id: cache-minui
      with:
        path: ${{ env.BUILD_DIR }}
        key: ${{ steps.version.outputs.cache_key }}

  build:
    name: "ğŸ”¨ Build MinUI"
    runs-on: ubuntu-latest
    needs: setup-and-patch
    strategy:
      matrix:
        python_version: ['3.9']
    
    steps:
    - name: "ğŸ“¦ Checkout builder"
      uses: actions/checkout@v4
      
    - name: "ğŸ“‚ Restore patched source from cache"
      id: restore-cache
      uses: actions/cache@v3
      with:
        path: ${{ env.BUILD_DIR }}
        key: ${{ needs.setup-and-patch.outputs.cache_key }}
        
    - name: "ğŸ“¥ Verify build directory exists"
      run: |
        echo "Checking build directory..."
        if [ -d "$BUILD_DIR" ]; then
          echo "âœ… Build directory exists: $(ls -la $BUILD_DIR/)"
          echo "Makefile exists: $(ls -la $BUILD_DIR/makefile 2>/dev/null || echo 'NOT FOUND')"
        else
          echo "âŒ Build directory not found! Creating from scratch..."
          git clone --depth 1 $MINUI_REPO $BUILD_DIR
        fi
        
    - name: "ğŸ“¥ Install dependencies"
      run: |
        echo "Installing build dependencies..."
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          git \
          wget \
          unzip \
          xxd \
          python3 \
          python3-pip \
          bc \
          libncurses5-dev
          
    - name: "ğŸ Setup Python"
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python_version }}
        
    - name: "ğŸ—ï¸ Build MinUI"
      env:
        TARGET: ${{ github.event.inputs.target_device || 'rg35xx' }}
        CLEAN_BUILD: ${{ github.event.inputs.clean_build || 'true' }}
        BUILD_VERSION: ${{ needs.setup-and-patch.outputs.build_version }}
      run: |
        echo "Starting MinUI build..."
        echo "Target: $TARGET"
        echo "Clean build: $CLEAN_BUILD"
        echo "Build version: $BUILD_VERSION"
        
        # Create build script
        cat > build-minui.sh << 'EOF'
        #!/bin/bash
        set -e
        
        BUILD_DIR="${{ env.BUILD_DIR }}"
        OUTPUT_DIR="${{ env.OUTPUT_DIR }}"
        TARGET="$TARGET"
        
        echo "Entering build directory: $BUILD_DIR"
        cd "$BUILD_DIR"
        
        # Clean if requested
        if [ "$CLEAN_BUILD" = "true" ]; then
          echo "ğŸ§¹ Cleaning build directory..."
          make clean || true
        fi
        
        # Build for target
        echo "ğŸ”¨ Building for target: $TARGET"
        
        # Try different make commands based on target
        case "$TARGET" in
          "rg35xx"|"rgb30"|"miyoomini")
            make platform="$TARGET" -j$(nproc)
            ;;
          "default")
            make -j$(nproc)
            ;;
          *)
            echo "âš ï¸ Unknown target: $TARGET, using default"
            make -j$(nproc)
            ;;
        esac
        
        # Check for build outputs
        echo "ğŸ“ Checking for build outputs..."
        
        # Create output directory
        mkdir -p "../$OUTPUT_DIR"
        
        # Copy any build artifacts
        find . -name "*.zip" -exec cp {} "../$OUTPUT_DIR/" \;
        find . -name "*.elf" -exec cp {} "../$OUTPUT_DIR/" \;
        find . -name "*.img" -exec cp {} "../$OUTPUT_DIR/" \;
        find . -name "*.bin" -exec cp {} "../$OUTPUT_DIR/" \;
        
        echo "âœ… Build completed!"
        EOF
        
        chmod +x build-minui.sh
        ./build-minui.sh
        
        echo "ğŸ“ Build outputs in $OUTPUT_DIR/:"
        ls -la $OUTPUT_DIR/ || echo "No output files found"
        
    - name: "ğŸ“¦ Package artifacts"
      run: |
        echo "Packaging artifacts..."
        mkdir -p packaged
        
        # Create package
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        PACKAGE_NAME="MinUI_${{ github.event.inputs.target_device || 'rg35xx' }}_$TIMESTAMP"
        
        if [ -d "$OUTPUT_DIR" ] && [ "$(ls -A $OUTPUT_DIR 2>/dev/null)" ]; then
          cp -r $OUTPUT_DIR/* packaged/
          echo "ğŸ“¦ Artifacts packaged"
        else
          echo "âš ï¸ No artifacts found, creating empty package"
          touch packaged/NO_ARTIFACTS.txt
          echo "No build artifacts were produced." > packaged/NO_ARTIFACTS.txt
        fi
        
        # Save build info
        echo "Build Information:" > packaged/BUILD_INFO.txt
        echo "Version: ${{ needs.setup-and-patch.outputs.build_version }}" >> packaged/BUILD_INFO.txt
        echo "Commit: ${{ needs.setup-and-patch.outputs.commit_hash }}" >> packaged/BUILD_INFO.txt
        echo "Target: ${{ github.event.inputs.target_device || 'rg35xx' }}" >> packaged/BUILD_INFO.txt
        echo "Date: $(date -u)" >> packaged/BUILD_INFO.txt
        
    - name: "ğŸ’¾ Upload build artifacts"
      uses: actions/upload-artifact@v4
      with:
        name: minui-build-${{ github.run_number }}
        path: |
          packaged/*
        retention-days: 30

  release:
    name: "ğŸš€ Create Release"
    needs: build
    if: github.event.inputs.create_release == 'true'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      
    steps:
    - name: "ğŸ“¥ Download artifacts"
      uses: actions/download-artifact@v4
      with:
        name: minui-build-${{ github.run_number }}
        path: release-assets
        
    - name: "ğŸ·ï¸ Create GitHub Release"
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ github.event.inputs.release_tag || format('build-{0}', github.run_number) }}
        name: "MinUI Build #${{ github.run_number }}"
        body: |
          ## MinUI CI Build
          
          **Build Information:**
          - Version: ${{ needs.setup-and-patch.outputs.build_version }}
          - Commit: ${{ needs.setup-and-patch.outputs.commit_hash }}
          - Target: ${{ github.event.inputs.target_device || 'rg35xx' }}
          - Build Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          
          **Artifacts:**
          - MinUI firmware image
          - Build logs
          
          ---
          
          *Automatically built by GitHub Actions*
          
        draft: false
        prerelease: false
        files: |
          release-assets/*
        generate_release_notes: true
